Totally fair—the ZIP you sent really does have no src/ code in it. Happens a lot with exports. No stress—I’ll get you back to a working site right now with a clean starter + the AI /smart_fetch endpoint.

Here’s the copy-paste fix. Do these in your Replit project:

1) Create these files
index.html (root)
html
Copy
Edit
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>BuildwiseAI</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
src/main.tsx
ts
Copy
Edit
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";

const root = createRoot(document.getElementById("root")!);
root.render(<App />);
src/App.tsx
tsx
Copy
Edit
import React, { useState } from "react";

export default function App() {
  const [q, setQ] = useState("permits near city hall");
  const [resp, setResp] = useState<any>(null);
  const [loading, setLoading] = useState(false);

  async function run() {
    setLoading(true);
    try {
      const r = await fetch(`/smart_fetch?q=${encodeURIComponent(q)}&city=Maple Ridge`);
      const data = await r.json();
      setResp(data);
    } catch (e) {
      setResp({ ok: false, error: String(e) });
    } finally {
      setLoading(false);
    }
  }

  return (
    <div style={{ fontFamily: "system-ui", padding: 24, maxWidth: 800, margin: "0 auto" }}>
      <h1>BuildwiseAI</h1>
      <p>Type a query and we’ll route to the best data source with validation.</p>
      <div style={{ display: "flex", gap: 8, marginTop: 16 }}>
        <input value={q} onChange={e => setQ(e.target.value)} style={{ flex: 1, padding: 8 }} />
        <button onClick={run} disabled={loading} style={{ padding: "8px 16px" }}>
          {loading ? "Loading..." : "Search"}
        </button>
      </div>
      <pre style={{ background: "#111", color: "#0f0", padding: 16, marginTop: 24, borderRadius: 8, overflowX: "auto" }}>
        {resp ? JSON.stringify(resp, null, 2) : "// results appear here"}
      </pre>
    </div>
  );
}
server.js (root)
js
Copy
Edit
const express = require("express");
const path = require("path");
const fetch = (...args) => import('node-fetch').then(({default: f}) => f(...args));

const app = express();
const PORT = process.env.PORT || 3000;

// ---- AI optimization layer: /smart_fetch ----
app.get("/smart_fetch", async (req, res) => {
  const q = (req.query.q || "").toString();
  const city = (req.query.city || "Maple Ridge").toString();

  // Replace these with real endpoints when ready
  const sources = [
    `https://example.com/opendata?q=${encodeURIComponent(q)}&city=${encodeURIComponent(city)}`,
    `https://example.com/city_api?q=${encodeURIComponent(q)}&city=${encodeURIComponent(city)}`,
    `https://example.com/scrape?q=${encodeURIComponent(q)}&city=${encodeURIComponent(city)}`
  ];

  const provenance = [];
  for (const url of sources) {
    try {
      const r = await fetch(url, { timeout: 10000 });
      const ct = r.headers.get("content-type") || "";
      const data = ct.includes("application/json") ? await r.json() : { text: await r.text() };
      provenance.push({ source: url, ok: r.ok, data, fetched_at: Date.now()/1000 });
    } catch (e) {
      provenance.push({ source: url, ok: false, data: { error: String(e) }, fetched_at: Date.now()/1000 });
    }
  }

  // Simple reconciliation & confidence
  const okOnes = provenance.filter(p => p.ok);
  let payload = {};
  let confidence = 0.0;
  let note = "No sources succeeded.";
  if (okOnes.length) {
    const pick = okOnes[0]; // later: choose by trust/recency/etc.
    payload = typeof pick.data === "object" ? pick.data : { raw: pick.data };
    confidence = 0.75;
    note = `Selected ${pick.source}`;
  }
  const ok = confidence >= 0.7 && Object.keys(payload).length > 0;
  return res.json({ ok, payload, confidence: Number(confidence.toFixed(2)), provenance, notes: ok ? null : note });
});

// ---- serve built frontend from /dist ----
app.use(express.static(path.join(__dirname, "dist")));
app.get("*", (_req, res) => res.sendFile(path.join(__dirname, "dist", "index.html")));

app.listen(PORT, () => console.log(`BuildwiseAI running on :${PORT}`));
2) Update package.json scripts
Open package.json and make sure you have these scripts:

json
Copy
Edit
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "start": "node server.js"
  }
}
3) Run it on Replit
First run: npm install (only if deps aren’t installed yet)

Build the front-end: npm run build

Start the server: npm start

Your app opens; test at:

/ (the UI)

/smart_fetch?q=test&city=Maple%20Ridge (the AI layer)

4) Next step (when you’re ready)
Give me 1–2 real data source URLs for Maple Ridge/Burnaby/Coquitlam and I’ll upgrade the /smart_fetch to:

try multiple sources with retries/timeouts,

validate/normalize fields,

score confidence by source trust & recency,

and return graceful fallbacks.

If you prefer, I can also switch this to Python/FastAPI—but the Node version above will work immediately with your current project.

Want me to keep going and add the trust/validation logic now with placeholder rules?